/* =========================
 * Lexical part
 * ========================= */

/* Regular definitions */
_digit  : '0'-'9' ;
_int    : _digit { _digit } ;

/* Tokens (must start with lowercase letters) */
frac    : _int '/' _int ;
float   : _int '.' _digit { _digit } ;
int     : _int ;

/* Newlines are NOT whitespace here; we keep them as tokens */
nl      : '\r' '\n' | '\n' | '\r' ;

/* Ignored tokens (suppressed by lexer) */
!ws     : ' ' | '\t' ;

/* '#' comments until end-of-line (excluding NL itself) */
_non_nl : '\u0000'-'\u0009' | '\u000B'-'\u000C' | '\u000E'-'\uFFFF' ;
!comment: '#' { _non_nl } ;

/* =========================
 * Syntax part
 * ========================= */


<<
import (
  "strconv"
  "strings"

  ast "github.com/fruity-loozrz/go-scratchpad/internal/automationast"
  "github.com/fruity-loozrz/go-scratchpad/internal/automationparser/token"
)
>>

Program
    : Lines          << ast.Program{Lines: $0.([]ast.Stmt)}, nil >>
    ;

Lines
    : "empty"         << []ast.Stmt{}, nil >>
    | Lines Line      << append($0.([]ast.Stmt), $1.([]ast.Stmt)...), nil >>
    ;

Line
    : nl              << []ast.Stmt{}, nil >>
    | Stmt nl         << []ast.Stmt{$0.(ast.Stmt)}, nil >>
    ;

Stmt
    : BpmStmt
    | MoveStmt
    ;

BpmStmt
    : "bpm" Number    << ast.BPM{Value: $1.(ast.Number)}, nil >>
    ;

MoveStmt
    : Dh              << ast.Move{DH: $0.(ast.Number), DT: nil}, nil >>
    | Dh Dt << func() (interface{}, error) {
          dt := $1.(ast.Number)
          return ast.Move{DH: $0.(ast.Number), DT: &dt}, nil
      }() >>
    ;

Dh
    : "+" << ast.Number{Kind:"int", Int:1}, nil >>
    | "-" << ast.Number{Kind:"int", Int:-1}, nil >>
    | "+" Number << func() (interface{}, error) {
          n := $1.(ast.Number)
          // применяем знак к Number
          switch n.Kind {
          case "int":
            n.Int = +n.Int
          case "float":
            n.Float = +n.Float
          case "frac":
            n.Num = +n.Num
          }
          return n, nil
      }() >>
    | "-" Number << func() (interface{}, error) {
          n := $1.(ast.Number)
          switch n.Kind {
          case "int":
            n.Int = -n.Int
          case "float":
            n.Float = -n.Float
          case "frac":
            n.Num = -n.Num
          }
          return n, nil
      }() >>
    | Number
    ;

Dt
    : Number << $0, nil >>
    ;

Number
    : frac << func() (interface{}, error) {
          lit := string($0.(*token.Token).Lit)
          parts := strings.SplitN(lit, "/", 2)
          a, err := strconv.ParseInt(parts[0], 10, 64)
          if err != nil { return nil, err }
          b, err := strconv.ParseInt(parts[1], 10, 64)
          if err != nil { return nil, err }
          return ast.Number{Kind:"frac", Num:a, Den:b}, nil
      }() >>
    | float << func() (interface{}, error) {
          lit := string($0.(*token.Token).Lit)
          f, err := strconv.ParseFloat(lit, 64)
          if err != nil { return nil, err }
          return ast.Number{Kind:"float", Float:f}, nil
      }() >>
    | int << func() (interface{}, error) {
          lit := string($0.(*token.Token).Lit)
          v, err := strconv.ParseInt(lit, 10, 64)
          if err != nil { return nil, err }
          return ast.Number{Kind:"int", Int:v}, nil
      }() >>
    ;
